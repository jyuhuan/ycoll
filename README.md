# YColl

This library aims at providing data structures (especially collections) that the standard library of the Scala programming language does not provide. 

> **WARNING**: This library is still under development. You may toy with the untested/unverified code, but please do **NOT** try to use this snapshot version in any actual work. 

The best way to use this library in your project is to add the following dependency to your `build.sbt` file:

```scala
resolvers += Resolver.sonatypeRepo("snapshots")
libraryDependencies += "me.yuhuan" %% "ycoll" % "0.0.0-SNAPSHOT"
```

## Features

In the current snapshot, a carefully designed representation for directed graphs, `Graph[I, V, E]`, is provided. Each **vertex** in the graph has an **index** and the corresponding **data**. Each **edge** in the graph has a **pair of vertex indices**, and the **data** it carries (typically the *weight* or the *label* of the edge). To provide maximum flexibility, the indices are generically typed as `I`, the vertex data are generically typed as `V`, and the edge data are generically typed as `E`. To provide as much efficiency as possible, `I` is specialized for `Int`, the most used type of index in many practical cases.

### Examples
The graphs in the following picture are used in examples in this section:

<img src="http://yuhuan.me/articles/img/ycoll-design/zip.png" width="600" /> 

#### Creating a Graph

Generally, a graph is created in the following syntax:


```scala
val g = AdjacencyMapGraph(/* vertices */)(/* edges */)
```

To create `graph1`, write:

```scala
val graph1 = AdjacencyMapGraph(
  0 → "A",
  1 → "B",
  2 → "C",
  3 → "D"
)(
  0 → "a" → 1,
  0 → "ab" → 2,
  0 → "abc" → 3,
  2 → "abcd" → 1,
  3 → "abcde" → 1
)
```


#### Tranforming a Graph
Some higher-order functions are provided at the level of the `Graph` trait. The higher order functions are by design *lazy*. In this example, we create `graph2` by mapping the vertices and edges in `graph1` to something else:

```scala
val graph2 = graph1.mapEdges(e ⇒ e.length)
                   .mapVertices(v ⇒ v match {
                     case "A" ⇒ "N0"
                     case "B" ⇒ "N1"
                     case "C" ⇒ "N2"
                     case "D" ⇒ "N3"
                     case "E" ⇒ "N4"
                     case _ ⇒ "Unknown"
                   })
```

`graph3` is in fact a combination of `graph1` and `graph2`. The corresponding vertices are simply combined as a pair, and so do corresponding edges. This is accomplished by a single line of code:

```scala
val graph3 = graph1.zip(graph2)
```


#### Searching
Since a `StateSpace` is defined on each vertex, one can easily perform various types of search on the graph. To use the default breadth-first graph search to find the path from vertex `A` (whose index is `0`) to `B` (whose index is `1`), simply write:

```scala
val pathAB = graph1.vertexAt(0) ~~> graph1.vertexAt(1)
```

A list of states along the shortest path will be returned, if any.


#### Graphviz Compatibility
One can easily output any `Graph` to a `dot` format. Simply invoke `str` on anything that is a `Graph`. For example, the three graphs in the figure at the beginning of these examples are generated by:

```scala
val dot1 = graph1.str
val dot2 = graph2.str
val dot3 = graph3.str
```

Notice that the formatter is actually implemented somewhere else rather than inside the graph, so an extra import line should be added to your code, if you want `str` to work.

```scala
import me.yuhuan.collection.graph._
```

## Road Map
* Bidirectional graph
* Undirected graph
* Multigraph (more than one edge can exist between two vertices)